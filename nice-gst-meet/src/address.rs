// Generated by gir (https://github.com/gtk-rs/gir @ 5433e2582f83)
// from C:\Users\dan\Documents\code\libnice\build\nice (@ ac4bb22ebbfc)
// from C:\vcpkg\installed\x64-windows\share\gir-1.0 (@ 65be7019941e)
// DO NOT EDIT

use crate::{ffi};
use glib::{translate::*};

glib::wrapper! {
    #[derive(Debug, PartialOrd, Ord, Hash)]
    pub struct Address(Boxed<ffi::NiceAddress>);

    match fn {
        copy => |ptr| glib::gobject_ffi::g_boxed_copy(ffi::nice_address_get_type(), ptr as *mut _) as *mut ffi::NiceAddress,
        free => |ptr| glib::gobject_ffi::g_boxed_free(ffi::nice_address_get_type(), ptr as *mut _),
        type_ => || ffi::nice_address_get_type(),
    }
}

impl Address {
    #[doc(alias = "nice_address_new")]
    pub fn new() -> Address {
        unsafe {
            from_glib_full(ffi::nice_address_new())
        }
    }

    //#[doc(alias = "nice_address_copy_to_sockaddr")]
    //pub fn copy_to_sockaddr(&self, sin: /*Unimplemented*/Option<Basic: Pointer>) {
    //    unsafe { TODO: call ffi:nice_address_copy_to_sockaddr() }
    //}

    #[doc(alias = "nice_address_dup")]
#[must_use]
    pub fn dup(&self) -> Option<Address> {
        unsafe {
            from_glib_full(ffi::nice_address_dup(self.to_glib_none().0))
        }
    }

    #[cfg(feature = "v0_1_20")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_20")))]
    #[doc(alias = "nice_address_dup_string")]
    pub fn dup_string(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::nice_address_dup_string(self.to_glib_none().0))
        }
    }

    #[doc(alias = "nice_address_equal")]
     fn equal(&self, b: &Address) -> bool {
        unsafe {
            from_glib(ffi::nice_address_equal(self.to_glib_none().0, b.to_glib_none().0))
        }
    }

    #[cfg(feature = "v0_1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_8")))]
    #[doc(alias = "nice_address_equal_no_port")]
    pub fn equal_no_port(&self, b: &Address) -> bool {
        unsafe {
            from_glib(ffi::nice_address_equal_no_port(self.to_glib_none().0, b.to_glib_none().0))
        }
    }

    #[doc(alias = "nice_address_get_port")]
    #[doc(alias = "get_port")]
    pub fn port(&self) -> u32 {
        unsafe {
            ffi::nice_address_get_port(self.to_glib_none().0)
        }
    }

    #[doc(alias = "nice_address_init")]
    pub fn init(&mut self) {
        unsafe {
            ffi::nice_address_init(self.to_glib_none_mut().0);
        }
    }

    #[doc(alias = "nice_address_ip_version")]
    pub fn ip_version(&self) -> i32 {
        unsafe {
            ffi::nice_address_ip_version(self.to_glib_none().0)
        }
    }

    #[cfg(feature = "v0_1_19")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_19")))]
    #[doc(alias = "nice_address_is_linklocal")]
    pub fn is_linklocal(&self) -> bool {
        unsafe {
            from_glib(ffi::nice_address_is_linklocal(self.to_glib_none().0))
        }
    }

    #[doc(alias = "nice_address_is_private")]
    pub fn is_private(&self) -> bool {
        unsafe {
            from_glib(ffi::nice_address_is_private(self.to_glib_none().0))
        }
    }

    #[doc(alias = "nice_address_is_valid")]
    pub fn is_valid(&self) -> bool {
        unsafe {
            from_glib(ffi::nice_address_is_valid(self.to_glib_none().0))
        }
    }

    //#[doc(alias = "nice_address_set_from_sockaddr")]
    //pub fn set_from_sockaddr(&mut self, sin: /*Unimplemented*/Option<Basic: Pointer>) {
    //    unsafe { TODO: call ffi:nice_address_set_from_sockaddr() }
    //}

    #[doc(alias = "nice_address_set_from_string")]
    pub fn set_from_string(&mut self, str: &str) -> bool {
        unsafe {
            from_glib(ffi::nice_address_set_from_string(self.to_glib_none_mut().0, str.to_glib_none().0))
        }
    }

    #[doc(alias = "nice_address_set_ipv4")]
    pub fn set_ipv4(&mut self, addr_ipv4: u32) {
        unsafe {
            ffi::nice_address_set_ipv4(self.to_glib_none_mut().0, addr_ipv4);
        }
    }

    #[doc(alias = "nice_address_set_ipv6")]
    pub fn set_ipv6(&mut self, addr_ipv6: u8) {
        unsafe {
            ffi::nice_address_set_ipv6(self.to_glib_none_mut().0, addr_ipv6);
        }
    }

    #[doc(alias = "nice_address_set_port")]
    pub fn set_port(&mut self, port: u32) {
        unsafe {
            ffi::nice_address_set_port(self.to_glib_none_mut().0, port);
        }
    }

    #[doc(alias = "nice_address_to_string")]
    pub fn to_string(&self, dst: &str) {
        unsafe {
            ffi::nice_address_to_string(self.to_glib_none().0, dst.to_glib_none().0);
        }
    }
}

impl Default for Address {
                     fn default() -> Self {
                         Self::new()
                     }
                 }

impl PartialEq for Address {
    #[inline]
    fn eq(&self, other: &Self) -> bool {
        self.equal(other)
    }
}

impl Eq for Address {}
