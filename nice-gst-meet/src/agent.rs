// Generated by gir (https://github.com/gtk-rs/gir @ 5433e2582f83)
// from C:\Users\dan\Documents\code\libnice\build\nice (@ ac4bb22ebbfc)
// from C:\vcpkg\installed\x64-windows\share\gir-1.0 (@ 65be7019941e)
// DO NOT EDIT

use crate::{ffi,Address,Candidate,RelayType};
#[cfg(feature = "v0_1_8")]
#[cfg_attr(docsrs, doc(cfg(feature = "v0_1_8")))]
use crate::{ComponentState};
use glib::{object::ObjectType as _,prelude::*,signal::{connect_raw, SignalHandlerId},translate::*};
use std::{boxed::Box as Box_};

glib::wrapper! {
    #[doc(alias = "NiceAgent")]
    pub struct Agent(Object<ffi::NiceAgent, ffi::NiceAgentClass>);

    match fn {
        type_ => || ffi::nice_agent_get_type(),
    }
}

impl Agent {
    //#[doc(alias = "nice_agent_new")]
    //pub fn new(ctx: /*Ignored*/&glib::MainContext, compat: Compatibility) -> Agent {
    //    unsafe { TODO: call ffi:nice_agent_new() }
    //}

    //#[cfg(feature = "v0_1_15")]
    //#[cfg_attr(docsrs, doc(cfg(feature = "v0_1_15")))]
    //#[doc(alias = "nice_agent_new_full")]
    //pub fn new_full(ctx: /*Ignored*/&glib::MainContext, compat: Compatibility, flags: AgentOption) -> Agent {
    //    unsafe { TODO: call ffi:nice_agent_new_full() }
    //}

    //#[doc(alias = "nice_agent_new_reliable")]
    //pub fn new_reliable(ctx: /*Ignored*/&glib::MainContext, compat: Compatibility) -> Agent {
    //    unsafe { TODO: call ffi:nice_agent_new_reliable() }
    //}

    #[doc(alias = "nice_agent_add_local_address")]
    pub fn add_local_address(&self, addr: &mut Address) -> bool {
        unsafe {
            from_glib(ffi::nice_agent_add_local_address(self.to_glib_none().0, addr.to_glib_none_mut().0))
        }
    }

    #[doc(alias = "nice_agent_add_stream")]
    pub fn add_stream(&self, n_components: u32) -> u32 {
        unsafe {
            ffi::nice_agent_add_stream(self.to_glib_none().0, n_components)
        }
    }

    //#[doc(alias = "nice_agent_attach_recv")]
    //pub fn attach_recv<P: Fn(&Agent, u32, u32, u32, &str) + 'static>(&self, stream_id: u32, component_id: u32, ctx: /*Ignored*/&glib::MainContext, func: P) -> bool {
    //    unsafe { TODO: call ffi:nice_agent_attach_recv() }
    //}

    //#[cfg(feature = "v0_1_16")]
    //#[cfg_attr(docsrs, doc(cfg(feature = "v0_1_16")))]
    //#[doc(alias = "nice_agent_close_async")]
    //pub fn close_async<P: FnOnce(Result<(), glib::Error>) + 'static>(&self, callback: P) {
    //    unsafe { TODO: call ffi:nice_agent_close_async() }
    //}

    #[cfg(feature = "v0_1_19")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_19")))]
    #[doc(alias = "nice_agent_consent_lost")]
    pub fn consent_lost(&self, stream_id: u32, component_id: u32) -> bool {
        unsafe {
            from_glib(ffi::nice_agent_consent_lost(self.to_glib_none().0, stream_id, component_id))
        }
    }

    #[cfg(feature = "v0_1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_6")))]
    #[doc(alias = "nice_agent_forget_relays")]
    pub fn forget_relays(&self, stream_id: u32, component_id: u32) -> bool {
        unsafe {
            from_glib(ffi::nice_agent_forget_relays(self.to_glib_none().0, stream_id, component_id))
        }
    }

    #[doc(alias = "nice_agent_gather_candidates")]
    pub fn gather_candidates(&self, stream_id: u32) -> bool {
        unsafe {
            from_glib(ffi::nice_agent_gather_candidates(self.to_glib_none().0, stream_id))
        }
    }

    #[cfg(feature = "v0_1_4")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_4")))]
    #[doc(alias = "nice_agent_generate_local_candidate_sdp")]
    pub fn generate_local_candidate_sdp(&self, candidate: &mut Candidate) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::nice_agent_generate_local_candidate_sdp(self.to_glib_none().0, candidate.to_glib_none_mut().0))
        }
    }

    #[cfg(feature = "v0_1_4")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_4")))]
    #[doc(alias = "nice_agent_generate_local_sdp")]
    pub fn generate_local_sdp(&self) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::nice_agent_generate_local_sdp(self.to_glib_none().0))
        }
    }

    #[cfg(feature = "v0_1_4")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_4")))]
    #[doc(alias = "nice_agent_generate_local_stream_sdp")]
    pub fn generate_local_stream_sdp(&self, stream_id: u32, include_non_ice: bool) -> Option<glib::GString> {
        unsafe {
            from_glib_full(ffi::nice_agent_generate_local_stream_sdp(self.to_glib_none().0, stream_id, include_non_ice.into_glib()))
        }
    }

    #[cfg(feature = "v0_1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_8")))]
    #[doc(alias = "nice_agent_get_component_state")]
    #[doc(alias = "get_component_state")]
    pub fn component_state(&self, stream_id: u32, component_id: u32) -> ComponentState {
        unsafe {
            from_glib(ffi::nice_agent_get_component_state(self.to_glib_none().0, stream_id, component_id))
        }
    }

    #[doc(alias = "nice_agent_get_default_local_candidate")]
    #[doc(alias = "get_default_local_candidate")]
    pub fn default_local_candidate(&self, stream_id: u32, component_id: u32) -> Option<Candidate> {
        unsafe {
            from_glib_full(ffi::nice_agent_get_default_local_candidate(self.to_glib_none().0, stream_id, component_id))
        }
    }

    //#[cfg(feature = "v0_1_5")]
    //#[cfg_attr(docsrs, doc(cfg(feature = "v0_1_5")))]
    //#[doc(alias = "nice_agent_get_io_stream")]
    //#[doc(alias = "get_io_stream")]
    //pub fn io_stream(&self, stream_id: u32, component_id: u32) -> /*Ignored*/Option<gio::IOStream> {
    //    unsafe { TODO: call ffi:nice_agent_get_io_stream() }
    //}

    #[doc(alias = "nice_agent_get_local_candidates")]
    #[doc(alias = "get_local_candidates")]
    pub fn local_candidates(&self, stream_id: u32, component_id: u32) -> Vec<Candidate> {
        unsafe {
            FromGlibPtrContainer::from_glib_full(ffi::nice_agent_get_local_candidates(self.to_glib_none().0, stream_id, component_id))
        }
    }

    #[doc(alias = "nice_agent_get_local_credentials")]
    #[doc(alias = "get_local_credentials")]
    pub fn local_credentials(&self, stream_id: u32) -> Option<(glib::GString, glib::GString)> {
        unsafe {
            let mut ufrag = std::ptr::null_mut();
            let mut pwd = std::ptr::null_mut();
            let ret = from_glib(ffi::nice_agent_get_local_credentials(self.to_glib_none().0, stream_id, &mut ufrag, &mut pwd));
            if ret { Some((from_glib_full(ufrag), from_glib_full(pwd))) } else { None }
        }
    }

    #[doc(alias = "nice_agent_get_remote_candidates")]
    #[doc(alias = "get_remote_candidates")]
    pub fn remote_candidates(&self, stream_id: u32, component_id: u32) -> Vec<Candidate> {
        unsafe {
            FromGlibPtrContainer::from_glib_full(ffi::nice_agent_get_remote_candidates(self.to_glib_none().0, stream_id, component_id))
        }
    }

    #[doc(alias = "nice_agent_get_selected_pair")]
    #[doc(alias = "get_selected_pair")]
    pub fn is_selected_pair(&self, stream_id: u32, component_id: u32, local: &mut Candidate, remote: &mut Candidate) -> bool {
        unsafe {
            from_glib(ffi::nice_agent_get_selected_pair(self.to_glib_none().0, stream_id, component_id, local.to_glib_none_mut().0, remote.to_glib_none_mut().0))
        }
    }

    //#[cfg(feature = "v0_1_5")]
    //#[cfg_attr(docsrs, doc(cfg(feature = "v0_1_5")))]
    //#[doc(alias = "nice_agent_get_selected_socket")]
    //#[doc(alias = "get_selected_socket")]
    //pub fn selected_socket(&self, stream_id: u32, component_id: u32) -> /*Ignored*/Option<gio::Socket> {
    //    unsafe { TODO: call ffi:nice_agent_get_selected_socket() }
    //}

    //#[cfg(feature = "v0_1_17")]
    //#[cfg_attr(docsrs, doc(cfg(feature = "v0_1_17")))]
    //#[doc(alias = "nice_agent_get_sockets")]
    //#[doc(alias = "get_sockets")]
    //pub fn sockets(&self, stream_id: u32, component_id: u32) -> /*Ignored*/Vec<gio::Socket> {
    //    unsafe { TODO: call ffi:nice_agent_get_sockets() }
    //}

    #[cfg(feature = "v0_1_4")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_4")))]
    #[doc(alias = "nice_agent_get_stream_name")]
    #[doc(alias = "get_stream_name")]
    pub fn stream_name(&self, stream_id: u32) -> Option<glib::GString> {
        unsafe {
            from_glib_none(ffi::nice_agent_get_stream_name(self.to_glib_none().0, stream_id))
        }
    }

    #[cfg(feature = "v0_1_4")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_4")))]
    #[doc(alias = "nice_agent_parse_remote_candidate_sdp")]
    pub fn parse_remote_candidate_sdp(&self, stream_id: u32, sdp: &str) -> Option<Candidate> {
        unsafe {
            from_glib_full(ffi::nice_agent_parse_remote_candidate_sdp(self.to_glib_none().0, stream_id, sdp.to_glib_none().0))
        }
    }

    #[cfg(feature = "v0_1_4")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_4")))]
    #[doc(alias = "nice_agent_parse_remote_sdp")]
    pub fn parse_remote_sdp(&self, sdp: &str) -> i32 {
        unsafe {
            ffi::nice_agent_parse_remote_sdp(self.to_glib_none().0, sdp.to_glib_none().0)
        }
    }

    #[cfg(feature = "v0_1_4")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_4")))]
    #[doc(alias = "nice_agent_parse_remote_stream_sdp")]
    pub fn parse_remote_stream_sdp(&self, stream_id: u32, sdp: &str, ufrag: &str, pwd: &str) -> Vec<Candidate> {
        unsafe {
            FromGlibPtrContainer::from_glib_full(ffi::nice_agent_parse_remote_stream_sdp(self.to_glib_none().0, stream_id, sdp.to_glib_none().0, ufrag.to_glib_none().0, pwd.to_glib_none().0))
        }
    }

    #[cfg(feature = "v0_1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_16")))]
    #[doc(alias = "nice_agent_peer_candidate_gathering_done")]
    pub fn peer_candidate_gathering_done(&self, stream_id: u32) -> bool {
        unsafe {
            from_glib(ffi::nice_agent_peer_candidate_gathering_done(self.to_glib_none().0, stream_id))
        }
    }

    //#[cfg(feature = "v0_1_5")]
    //#[cfg_attr(docsrs, doc(cfg(feature = "v0_1_5")))]
    //#[doc(alias = "nice_agent_recv")]
    //pub fn recv(&self, stream_id: u32, component_id: u32, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<glib::Error>) -> Result<(isize, Vec<u8>), glib::Error> {
    //    unsafe { TODO: call ffi:nice_agent_recv() }
    //}

    //#[cfg(feature = "v0_1_5")]
    //#[cfg_attr(docsrs, doc(cfg(feature = "v0_1_5")))]
    //#[doc(alias = "nice_agent_recv_messages")]
    //pub fn recv_messages(&self, stream_id: u32, component_id: u32, messages: /*Ignored*/Vec<InputMessage>, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<glib::Error>) -> Result<i32, u32, glib::Error> {
    //    unsafe { TODO: call ffi:nice_agent_recv_messages() }
    //}

    //#[cfg(feature = "v0_1_5")]
    //#[cfg_attr(docsrs, doc(cfg(feature = "v0_1_5")))]
    //#[doc(alias = "nice_agent_recv_messages_nonblocking")]
    //pub fn recv_messages_nonblocking(&self, stream_id: u32, component_id: u32, messages: /*Ignored*/Vec<InputMessage>, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<glib::Error>) -> Result<i32, u32, glib::Error> {
    //    unsafe { TODO: call ffi:nice_agent_recv_messages_nonblocking() }
    //}

    //#[cfg(feature = "v0_1_5")]
    //#[cfg_attr(docsrs, doc(cfg(feature = "v0_1_5")))]
    //#[doc(alias = "nice_agent_recv_nonblocking")]
    //pub fn recv_nonblocking(&self, stream_id: u32, component_id: u32, cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<glib::Error>) -> Result<(isize, Vec<u8>), glib::Error> {
    //    unsafe { TODO: call ffi:nice_agent_recv_nonblocking() }
    //}

    #[doc(alias = "nice_agent_remove_stream")]
    pub fn remove_stream(&self, stream_id: u32) {
        unsafe {
            ffi::nice_agent_remove_stream(self.to_glib_none().0, stream_id);
        }
    }

    #[doc(alias = "nice_agent_restart")]
    pub fn restart(&self) -> bool {
        unsafe {
            from_glib(ffi::nice_agent_restart(self.to_glib_none().0))
        }
    }

    #[cfg(feature = "v0_1_6")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_6")))]
    #[doc(alias = "nice_agent_restart_stream")]
    pub fn restart_stream(&self, stream_id: u32) -> bool {
        unsafe {
            from_glib(ffi::nice_agent_restart_stream(self.to_glib_none().0, stream_id))
        }
    }

    #[doc(alias = "nice_agent_send")]
    pub fn send(&self, stream_id: u32, component_id: u32, len: u32, buf: &str) -> i32 {
        unsafe {
            ffi::nice_agent_send(self.to_glib_none().0, stream_id, component_id, len, buf.to_glib_none().0)
        }
    }

    //#[cfg(feature = "v0_1_5")]
    //#[cfg_attr(docsrs, doc(cfg(feature = "v0_1_5")))]
    //#[doc(alias = "nice_agent_send_messages_nonblocking")]
    //pub fn send_messages_nonblocking(&self, stream_id: u32, component_id: u32, messages: /*Ignored*/&[OutputMessage], cancellable: /*Ignored*/Option<&gio::Cancellable>, error: /*Ignored*/Option<glib::Error>) -> i32 {
    //    unsafe { TODO: call ffi:nice_agent_send_messages_nonblocking() }
    //}

    #[doc(alias = "nice_agent_set_local_credentials")]
    pub fn set_local_credentials(&self, stream_id: u32, ufrag: &str, pwd: &str) -> bool {
        unsafe {
            from_glib(ffi::nice_agent_set_local_credentials(self.to_glib_none().0, stream_id, ufrag.to_glib_none().0, pwd.to_glib_none().0))
        }
    }

    #[doc(alias = "nice_agent_set_port_range")]
    pub fn set_port_range(&self, stream_id: u32, component_id: u32, min_port: u32, max_port: u32) {
        unsafe {
            ffi::nice_agent_set_port_range(self.to_glib_none().0, stream_id, component_id, min_port, max_port);
        }
    }

    #[doc(alias = "nice_agent_set_relay_info")]
    pub fn set_relay_info(&self, stream_id: u32, component_id: u32, server_ip: &str, server_port: u32, username: &str, password: &str, type_: RelayType) -> bool {
        unsafe {
            from_glib(ffi::nice_agent_set_relay_info(self.to_glib_none().0, stream_id, component_id, server_ip.to_glib_none().0, server_port, username.to_glib_none().0, password.to_glib_none().0, type_.into_glib()))
        }
    }

    #[doc(alias = "nice_agent_set_remote_candidates")]
    pub fn set_remote_candidates(&self, stream_id: u32, component_id: u32, candidates: &[Candidate]) -> i32 {
        unsafe {
            ffi::nice_agent_set_remote_candidates(self.to_glib_none().0, stream_id, component_id, candidates.to_glib_none().0)
        }
    }

    #[doc(alias = "nice_agent_set_remote_credentials")]
    pub fn set_remote_credentials(&self, stream_id: u32, ufrag: &str, pwd: &str) -> bool {
        unsafe {
            from_glib(ffi::nice_agent_set_remote_credentials(self.to_glib_none().0, stream_id, ufrag.to_glib_none().0, pwd.to_glib_none().0))
        }
    }

    #[doc(alias = "nice_agent_set_selected_pair")]
    pub fn set_selected_pair(&self, stream_id: u32, component_id: u32, lfoundation: &str, rfoundation: &str) -> bool {
        unsafe {
            from_glib(ffi::nice_agent_set_selected_pair(self.to_glib_none().0, stream_id, component_id, lfoundation.to_glib_none().0, rfoundation.to_glib_none().0))
        }
    }

    #[doc(alias = "nice_agent_set_selected_remote_candidate")]
    pub fn set_selected_remote_candidate(&self, stream_id: u32, component_id: u32, candidate: &mut Candidate) -> bool {
        unsafe {
            from_glib(ffi::nice_agent_set_selected_remote_candidate(self.to_glib_none().0, stream_id, component_id, candidate.to_glib_none_mut().0))
        }
    }

    #[doc(alias = "nice_agent_set_software")]
    pub fn set_software(&self, software: &str) {
        unsafe {
            ffi::nice_agent_set_software(self.to_glib_none().0, software.to_glib_none().0);
        }
    }

    #[cfg(feature = "v0_1_4")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_4")))]
    #[doc(alias = "nice_agent_set_stream_name")]
    pub fn set_stream_name(&self, stream_id: u32, name: &str) -> bool {
        unsafe {
            from_glib(ffi::nice_agent_set_stream_name(self.to_glib_none().0, stream_id, name.to_glib_none().0))
        }
    }

    #[doc(alias = "nice_agent_set_stream_tos")]
    pub fn set_stream_tos(&self, stream_id: u32, tos: i32) {
        unsafe {
            ffi::nice_agent_set_stream_tos(self.to_glib_none().0, stream_id, tos);
        }
    }

    #[cfg(feature = "v0_1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_8")))]
    #[doc(alias = "bytestream-tcp")]
    pub fn is_bytestream_tcp(&self) -> bool {
        ObjectExt::property(self, "bytestream-tcp")
    }

    #[cfg(feature = "v0_1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_8")))]
    #[doc(alias = "bytestream-tcp")]
    pub fn set_bytestream_tcp(&self, bytestream_tcp: bool) {
        ObjectExt::set_property(self,"bytestream-tcp", bytestream_tcp)
    }

    pub fn compatibility(&self) -> u32 {
        ObjectExt::property(self, "compatibility")
    }

    #[cfg(feature = "v0_1_19")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_19")))]
    #[doc(alias = "consent-freshness")]
    pub fn is_consent_freshness(&self) -> bool {
        ObjectExt::property(self, "consent-freshness")
    }

    #[doc(alias = "controlling-mode")]
    pub fn is_controlling_mode(&self) -> bool {
        ObjectExt::property(self, "controlling-mode")
    }

    #[doc(alias = "controlling-mode")]
    pub fn set_controlling_mode(&self, controlling_mode: bool) {
        ObjectExt::set_property(self,"controlling-mode", controlling_mode)
    }

    #[cfg(feature = "v0_1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_14")))]
    #[doc(alias = "force-relay")]
    pub fn is_force_relay(&self) -> bool {
        ObjectExt::property(self, "force-relay")
    }

    #[cfg(feature = "v0_1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_14")))]
    #[doc(alias = "force-relay")]
    pub fn set_force_relay(&self, force_relay: bool) {
        ObjectExt::set_property(self,"force-relay", force_relay)
    }

    #[doc(alias = "full-mode")]
    pub fn is_full_mode(&self) -> bool {
        ObjectExt::property(self, "full-mode")
    }

    #[cfg(feature = "v0_1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_8")))]
    #[doc(alias = "ice-tcp")]
    pub fn is_ice_tcp(&self) -> bool {
        ObjectExt::property(self, "ice-tcp")
    }

    #[cfg(feature = "v0_1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_8")))]
    #[doc(alias = "ice-tcp")]
    pub fn set_ice_tcp(&self, ice_tcp: bool) {
        ObjectExt::set_property(self,"ice-tcp", ice_tcp)
    }

    #[cfg(feature = "v0_1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_16")))]
    #[doc(alias = "ice-trickle")]
    pub fn is_ice_trickle(&self) -> bool {
        ObjectExt::property(self, "ice-trickle")
    }

    #[cfg(feature = "v0_1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_16")))]
    #[doc(alias = "ice-trickle")]
    pub fn set_ice_trickle(&self, ice_trickle: bool) {
        ObjectExt::set_property(self,"ice-trickle", ice_trickle)
    }

    #[cfg(feature = "v0_1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_8")))]
    #[doc(alias = "ice-udp")]
    pub fn is_ice_udp(&self) -> bool {
        ObjectExt::property(self, "ice-udp")
    }

    #[cfg(feature = "v0_1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_8")))]
    #[doc(alias = "ice-udp")]
    pub fn set_ice_udp(&self, ice_udp: bool) {
        ObjectExt::set_property(self,"ice-udp", ice_udp)
    }

    #[cfg(feature = "v0_1_17")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_17")))]
    #[doc(alias = "idle-timeout")]
    pub fn idle_timeout(&self) -> u32 {
        ObjectExt::property(self, "idle-timeout")
    }

    #[cfg(feature = "v0_1_17")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_17")))]
    #[doc(alias = "idle-timeout")]
    pub fn set_idle_timeout(&self, idle_timeout: u32) {
        ObjectExt::set_property(self,"idle-timeout", idle_timeout)
    }

    #[cfg(feature = "v0_1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_8")))]
    #[doc(alias = "keepalive-conncheck")]
    pub fn is_keepalive_conncheck(&self) -> bool {
        ObjectExt::property(self, "keepalive-conncheck")
    }

    #[cfg(feature = "v0_1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_8")))]
    #[doc(alias = "keepalive-conncheck")]
    pub fn set_keepalive_conncheck(&self, keepalive_conncheck: bool) {
        ObjectExt::set_property(self,"keepalive-conncheck", keepalive_conncheck)
    }

    //#[doc(alias = "main-context")]
    //pub fn main_context(&self) -> /*Unimplemented*/Basic: Pointer {
    //    ObjectExt::property(self, "main-context")
    //}

    #[doc(alias = "max-connectivity-checks")]
    pub fn max_connectivity_checks(&self) -> u32 {
        ObjectExt::property(self, "max-connectivity-checks")
    }

    #[doc(alias = "max-connectivity-checks")]
    pub fn set_max_connectivity_checks(&self, max_connectivity_checks: u32) {
        ObjectExt::set_property(self,"max-connectivity-checks", max_connectivity_checks)
    }

    //#[cfg(feature = "v0_1_20")]
    //#[cfg_attr(docsrs, doc(cfg(feature = "v0_1_20")))]
    //#[doc(alias = "proxy-extra-headers")]
    //pub fn proxy_extra_headers(&self) -> /*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 } {
    //    ObjectExt::property(self, "proxy-extra-headers")
    //}

    //#[cfg(feature = "v0_1_20")]
    //#[cfg_attr(docsrs, doc(cfg(feature = "v0_1_20")))]
    //#[doc(alias = "proxy-extra-headers")]
    //pub fn set_proxy_extra_headers(&self, proxy_extra_headers: /*Unimplemented*/HashTable TypeId { ns_id: 0, id: 28 }/TypeId { ns_id: 0, id: 28 }) {
    //    ObjectExt::set_property(self,"proxy-extra-headers", proxy_extra_headers)
    //}

    #[doc(alias = "proxy-ip")]
    pub fn proxy_ip(&self) -> Option<glib::GString> {
        ObjectExt::property(self, "proxy-ip")
    }

    #[doc(alias = "proxy-ip")]
    pub fn set_proxy_ip(&self, proxy_ip: Option<&str>) {
        ObjectExt::set_property(self,"proxy-ip", proxy_ip)
    }

    #[doc(alias = "proxy-password")]
    pub fn proxy_password(&self) -> Option<glib::GString> {
        ObjectExt::property(self, "proxy-password")
    }

    #[doc(alias = "proxy-password")]
    pub fn set_proxy_password(&self, proxy_password: Option<&str>) {
        ObjectExt::set_property(self,"proxy-password", proxy_password)
    }

    #[doc(alias = "proxy-port")]
    pub fn proxy_port(&self) -> u32 {
        ObjectExt::property(self, "proxy-port")
    }

    #[doc(alias = "proxy-port")]
    pub fn set_proxy_port(&self, proxy_port: u32) {
        ObjectExt::set_property(self,"proxy-port", proxy_port)
    }

    #[doc(alias = "proxy-type")]
    pub fn proxy_type(&self) -> u32 {
        ObjectExt::property(self, "proxy-type")
    }

    #[doc(alias = "proxy-type")]
    pub fn set_proxy_type(&self, proxy_type: u32) {
        ObjectExt::set_property(self,"proxy-type", proxy_type)
    }

    #[doc(alias = "proxy-username")]
    pub fn proxy_username(&self) -> Option<glib::GString> {
        ObjectExt::property(self, "proxy-username")
    }

    #[doc(alias = "proxy-username")]
    pub fn set_proxy_username(&self, proxy_username: Option<&str>) {
        ObjectExt::set_property(self,"proxy-username", proxy_username)
    }

    pub fn is_reliable(&self) -> bool {
        ObjectExt::property(self, "reliable")
    }

    #[cfg(feature = "v0_1_15")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_15")))]
    #[doc(alias = "stun-initial-timeout")]
    pub fn stun_initial_timeout(&self) -> u32 {
        ObjectExt::property(self, "stun-initial-timeout")
    }

    #[cfg(feature = "v0_1_15")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_15")))]
    #[doc(alias = "stun-initial-timeout")]
    pub fn set_stun_initial_timeout(&self, stun_initial_timeout: u32) {
        ObjectExt::set_property(self,"stun-initial-timeout", stun_initial_timeout)
    }

    #[cfg(feature = "v0_1_15")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_15")))]
    #[doc(alias = "stun-max-retransmissions")]
    pub fn stun_max_retransmissions(&self) -> u32 {
        ObjectExt::property(self, "stun-max-retransmissions")
    }

    #[cfg(feature = "v0_1_15")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_15")))]
    #[doc(alias = "stun-max-retransmissions")]
    pub fn set_stun_max_retransmissions(&self, stun_max_retransmissions: u32) {
        ObjectExt::set_property(self,"stun-max-retransmissions", stun_max_retransmissions)
    }

    #[doc(alias = "stun-pacing-timer")]
    pub fn stun_pacing_timer(&self) -> u32 {
        ObjectExt::property(self, "stun-pacing-timer")
    }

    #[doc(alias = "stun-pacing-timer")]
    pub fn set_stun_pacing_timer(&self, stun_pacing_timer: u32) {
        ObjectExt::set_property(self,"stun-pacing-timer", stun_pacing_timer)
    }

    #[cfg(feature = "v0_1_15")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_15")))]
    #[doc(alias = "stun-reliable-timeout")]
    pub fn stun_reliable_timeout(&self) -> u32 {
        ObjectExt::property(self, "stun-reliable-timeout")
    }

    #[cfg(feature = "v0_1_15")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_15")))]
    #[doc(alias = "stun-reliable-timeout")]
    pub fn set_stun_reliable_timeout(&self, stun_reliable_timeout: u32) {
        ObjectExt::set_property(self,"stun-reliable-timeout", stun_reliable_timeout)
    }

    #[doc(alias = "stun-server")]
    pub fn stun_server(&self) -> Option<glib::GString> {
        ObjectExt::property(self, "stun-server")
    }

    #[doc(alias = "stun-server")]
    pub fn set_stun_server(&self, stun_server: Option<&str>) {
        ObjectExt::set_property(self,"stun-server", stun_server)
    }

    #[doc(alias = "stun-server-port")]
    pub fn stun_server_port(&self) -> u32 {
        ObjectExt::property(self, "stun-server-port")
    }

    #[doc(alias = "stun-server-port")]
    pub fn set_stun_server_port(&self, stun_server_port: u32) {
        ObjectExt::set_property(self,"stun-server-port", stun_server_port)
    }

    #[doc(alias = "support-renomination")]
    pub fn supports_renomination(&self) -> bool {
        ObjectExt::property(self, "support-renomination")
    }

    #[doc(alias = "support-renomination")]
    pub fn set_support_renomination(&self, support_renomination: bool) {
        ObjectExt::set_property(self,"support-renomination", support_renomination)
    }

    pub fn is_upnp(&self) -> bool {
        ObjectExt::property(self, "upnp")
    }

    pub fn set_upnp(&self, upnp: bool) {
        ObjectExt::set_property(self,"upnp", upnp)
    }

    #[doc(alias = "upnp-timeout")]
    pub fn upnp_timeout(&self) -> u32 {
        ObjectExt::property(self, "upnp-timeout")
    }

    #[doc(alias = "upnp-timeout")]
    pub fn set_upnp_timeout(&self, upnp_timeout: u32) {
        ObjectExt::set_property(self,"upnp-timeout", upnp_timeout)
    }

    #[doc(alias = "candidate-gathering-done")]
    pub fn connect_candidate_gathering_done<F: Fn(&Self, u32) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn candidate_gathering_done_trampoline<F: Fn(&Agent, u32) + 'static>(this: *mut ffi::NiceAgent, stream_id: std::ffi::c_uint, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), stream_id)
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"candidate-gathering-done".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(candidate_gathering_done_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "component-state-changed")]
    pub fn connect_component_state_changed<F: Fn(&Self, u32, u32, u32) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn component_state_changed_trampoline<F: Fn(&Agent, u32, u32, u32) + 'static>(this: *mut ffi::NiceAgent, stream_id: std::ffi::c_uint, component_id: std::ffi::c_uint, state: std::ffi::c_uint, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), stream_id, component_id, state)
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"component-state-changed".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(component_state_changed_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "initial-binding-request-received")]
    pub fn connect_initial_binding_request_received<F: Fn(&Self, u32) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn initial_binding_request_received_trampoline<F: Fn(&Agent, u32) + 'static>(this: *mut ffi::NiceAgent, stream_id: std::ffi::c_uint, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), stream_id)
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"initial-binding-request-received".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(initial_binding_request_received_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg_attr(feature = "v0_1_8", deprecated = "Since 0.1.8")]
    #[doc(alias = "new-candidate")]
    pub fn connect_new_candidate<F: Fn(&Self, u32, u32, &str) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn new_candidate_trampoline<F: Fn(&Agent, u32, u32, &str) + 'static>(this: *mut ffi::NiceAgent, stream_id: std::ffi::c_uint, component_id: std::ffi::c_uint, foundation: *mut std::ffi::c_char, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), stream_id, component_id, &glib::GString::from_glib_borrow(foundation))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"new-candidate".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(new_candidate_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v0_1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_8")))]
    #[doc(alias = "new-candidate-full")]
    pub fn connect_new_candidate_full<F: Fn(&Self, &Candidate) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn new_candidate_full_trampoline<F: Fn(&Agent, &Candidate) + 'static>(this: *mut ffi::NiceAgent, candidate: *mut ffi::NiceCandidate, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), &from_glib_borrow(candidate))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"new-candidate-full".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(new_candidate_full_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg_attr(feature = "v0_1_8", deprecated = "Since 0.1.8")]
    #[doc(alias = "new-remote-candidate")]
    pub fn connect_new_remote_candidate<F: Fn(&Self, u32, u32, &str) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn new_remote_candidate_trampoline<F: Fn(&Agent, u32, u32, &str) + 'static>(this: *mut ffi::NiceAgent, stream_id: std::ffi::c_uint, component_id: std::ffi::c_uint, foundation: *mut std::ffi::c_char, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), stream_id, component_id, &glib::GString::from_glib_borrow(foundation))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"new-remote-candidate".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(new_remote_candidate_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v0_1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_8")))]
    #[doc(alias = "new-remote-candidate-full")]
    pub fn connect_new_remote_candidate_full<F: Fn(&Self, &Candidate) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn new_remote_candidate_full_trampoline<F: Fn(&Agent, &Candidate) + 'static>(this: *mut ffi::NiceAgent, candidate: *mut ffi::NiceCandidate, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), &from_glib_borrow(candidate))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"new-remote-candidate-full".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(new_remote_candidate_full_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg_attr(feature = "v0_1_8", deprecated = "Since 0.1.8")]
    #[doc(alias = "new-selected-pair")]
    pub fn connect_new_selected_pair<F: Fn(&Self, u32, u32, &str, &str) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn new_selected_pair_trampoline<F: Fn(&Agent, u32, u32, &str, &str) + 'static>(this: *mut ffi::NiceAgent, stream_id: std::ffi::c_uint, component_id: std::ffi::c_uint, lfoundation: *mut std::ffi::c_char, rfoundation: *mut std::ffi::c_char, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), stream_id, component_id, &glib::GString::from_glib_borrow(lfoundation), &glib::GString::from_glib_borrow(rfoundation))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"new-selected-pair".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(new_selected_pair_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v0_1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_8")))]
    #[doc(alias = "new-selected-pair-full")]
    pub fn connect_new_selected_pair_full<F: Fn(&Self, u32, u32, &Candidate, &Candidate) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn new_selected_pair_full_trampoline<F: Fn(&Agent, u32, u32, &Candidate, &Candidate) + 'static>(this: *mut ffi::NiceAgent, stream_id: std::ffi::c_uint, component_id: std::ffi::c_uint, lcandidate: *mut ffi::NiceCandidate, rcandidate: *mut ffi::NiceCandidate, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), stream_id, component_id, &from_glib_borrow(lcandidate), &from_glib_borrow(rcandidate))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"new-selected-pair-full".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(new_selected_pair_full_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "reliable-transport-writable")]
    pub fn connect_reliable_transport_writable<F: Fn(&Self, u32, u32) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn reliable_transport_writable_trampoline<F: Fn(&Agent, u32, u32) + 'static>(this: *mut ffi::NiceAgent, stream_id: std::ffi::c_uint, component_id: std::ffi::c_uint, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this), stream_id, component_id)
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"reliable-transport-writable".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(reliable_transport_writable_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    //#[cfg(feature = "v0_1_5")]
    //#[cfg_attr(docsrs, doc(cfg(feature = "v0_1_5")))]
    //#[doc(alias = "streams-removed")]
    //pub fn connect_streams_removed<Unsupported or ignored types>(&self, f: F) -> SignalHandlerId {
    //    Empty ctype stream_ids: *.CArray TypeId { ns_id: 0, id: 15 }
    //}

    #[cfg(feature = "v0_1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_8")))]
    #[doc(alias = "bytestream-tcp")]
    pub fn connect_bytestream_tcp_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_bytestream_tcp_trampoline<F: Fn(&Agent) + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::bytestream-tcp".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_bytestream_tcp_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "controlling-mode")]
    pub fn connect_controlling_mode_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_controlling_mode_trampoline<F: Fn(&Agent) + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::controlling-mode".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_controlling_mode_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v0_1_14")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_14")))]
    #[doc(alias = "force-relay")]
    pub fn connect_force_relay_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_force_relay_trampoline<F: Fn(&Agent) + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::force-relay".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_force_relay_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v0_1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_8")))]
    #[doc(alias = "ice-tcp")]
    pub fn connect_ice_tcp_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_ice_tcp_trampoline<F: Fn(&Agent) + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::ice-tcp".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_ice_tcp_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v0_1_16")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_16")))]
    #[doc(alias = "ice-trickle")]
    pub fn connect_ice_trickle_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_ice_trickle_trampoline<F: Fn(&Agent) + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::ice-trickle".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_ice_trickle_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v0_1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_8")))]
    #[doc(alias = "ice-udp")]
    pub fn connect_ice_udp_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_ice_udp_trampoline<F: Fn(&Agent) + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::ice-udp".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_ice_udp_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v0_1_17")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_17")))]
    #[doc(alias = "idle-timeout")]
    pub fn connect_idle_timeout_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_idle_timeout_trampoline<F: Fn(&Agent) + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::idle-timeout".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_idle_timeout_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v0_1_8")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_8")))]
    #[doc(alias = "keepalive-conncheck")]
    pub fn connect_keepalive_conncheck_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_keepalive_conncheck_trampoline<F: Fn(&Agent) + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::keepalive-conncheck".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_keepalive_conncheck_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "max-connectivity-checks")]
    pub fn connect_max_connectivity_checks_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_max_connectivity_checks_trampoline<F: Fn(&Agent) + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::max-connectivity-checks".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_max_connectivity_checks_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v0_1_20")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_20")))]
    #[doc(alias = "proxy-extra-headers")]
    pub fn connect_proxy_extra_headers_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_proxy_extra_headers_trampoline<F: Fn(&Agent) + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::proxy-extra-headers".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_proxy_extra_headers_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "proxy-ip")]
    pub fn connect_proxy_ip_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_proxy_ip_trampoline<F: Fn(&Agent) + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::proxy-ip".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_proxy_ip_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "proxy-password")]
    pub fn connect_proxy_password_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_proxy_password_trampoline<F: Fn(&Agent) + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::proxy-password".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_proxy_password_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "proxy-port")]
    pub fn connect_proxy_port_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_proxy_port_trampoline<F: Fn(&Agent) + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::proxy-port".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_proxy_port_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "proxy-type")]
    pub fn connect_proxy_type_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_proxy_type_trampoline<F: Fn(&Agent) + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::proxy-type".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_proxy_type_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "proxy-username")]
    pub fn connect_proxy_username_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_proxy_username_trampoline<F: Fn(&Agent) + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::proxy-username".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_proxy_username_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v0_1_15")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_15")))]
    #[doc(alias = "stun-initial-timeout")]
    pub fn connect_stun_initial_timeout_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_stun_initial_timeout_trampoline<F: Fn(&Agent) + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::stun-initial-timeout".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_stun_initial_timeout_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v0_1_15")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_15")))]
    #[doc(alias = "stun-max-retransmissions")]
    pub fn connect_stun_max_retransmissions_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_stun_max_retransmissions_trampoline<F: Fn(&Agent) + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::stun-max-retransmissions".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_stun_max_retransmissions_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "stun-pacing-timer")]
    pub fn connect_stun_pacing_timer_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_stun_pacing_timer_trampoline<F: Fn(&Agent) + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::stun-pacing-timer".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_stun_pacing_timer_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[cfg(feature = "v0_1_15")]
    #[cfg_attr(docsrs, doc(cfg(feature = "v0_1_15")))]
    #[doc(alias = "stun-reliable-timeout")]
    pub fn connect_stun_reliable_timeout_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_stun_reliable_timeout_trampoline<F: Fn(&Agent) + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::stun-reliable-timeout".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_stun_reliable_timeout_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "stun-server")]
    pub fn connect_stun_server_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_stun_server_trampoline<F: Fn(&Agent) + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::stun-server".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_stun_server_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "stun-server-port")]
    pub fn connect_stun_server_port_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_stun_server_port_trampoline<F: Fn(&Agent) + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::stun-server-port".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_stun_server_port_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "support-renomination")]
    pub fn connect_support_renomination_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_support_renomination_trampoline<F: Fn(&Agent) + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::support-renomination".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_support_renomination_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "upnp")]
    pub fn connect_upnp_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_upnp_trampoline<F: Fn(&Agent) + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::upnp".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_upnp_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }

    #[doc(alias = "upnp-timeout")]
    pub fn connect_upnp_timeout_notify<F: Fn(&Self) + 'static>(&self, f: F) -> SignalHandlerId {
        unsafe extern "C" fn notify_upnp_timeout_trampoline<F: Fn(&Agent) + 'static>(this: *mut ffi::NiceAgent, _param_spec: glib::ffi::gpointer, f: glib::ffi::gpointer) {
            let f: &F = &*(f as *const F);
            f(&from_glib_borrow(this))
        }
        unsafe {
            let f: Box_<F> = Box_::new(f);
            connect_raw(self.as_ptr() as *mut _, c"notify::upnp-timeout".as_ptr() as *const _,
                Some(std::mem::transmute::<*const (), unsafe extern "C" fn()>(notify_upnp_timeout_trampoline::<F> as *const ())), Box_::into_raw(f))
        }
    }
}
